<?php
// скрипт обработки проверки доступности команд для контроллера

// удаляем ненужные заголовки PHP, чтобы в ESP не сыпалось лишнего
header_remove();

$incoming_data = $_POST; // здесь - откуда получать параметры запроса

function dumpRequest() // дампим запрос в файл
{
  $req_dump = print_r($_REQUEST,TRUE);
  $fp = fopen('request.log','a');
  if($fp !== FALSE)
  {
      fwrite($fp,"===================================================================\r\n");
      fwrite($fp,$req_dump);
      fwrite($fp, "\r\n");
      fclose($fp);
  }
}
// ЗАКОММЕНТИРОВАТЬ, ЕСЛИ НЕ НУЖНА ИНФА ПО ПРИШЕДШЕМУ ЗАПРОСУ !!!
dumpRequest();

/*

  ЗА ОДИН РАЗ МОЖНО ОТСЫЛАТЬ НЕ БОЛЕЕ ПЯТИ КОМАНД!

  Данные запрашиваются методом POST, от контроллера приходит:
  
    k = (key) ключ для доступа к API
    s = (status) текущее состояние контроллера (пока не реализовано)
    r = (report) - если эта переменная установлена - то это ответ на выполнение команды
    c = (command) - содержит идентификатор выполненной команды (только если r установлена!)
    
    при обращении к сервису контроллер также передаёт локальные дату и время, а также таймзону:
    
      d - дата контроллера, в формате DD.MM.YYYY
      t - время контроллера, в формате HH:MM:SS
      z - смещение в минутах от UTC, например, -180 или 120
    
  Формат отсыла команд:
   
      1. Каждая команда начинается префиксом [~] и заканчивается переводом строки (\r\n)
      2. После префикса идёт идентификатор команды в системе, после идентификатора - символ #
      3. После символа # идёт текст команды, который может быть как прямым текстом команды (CTSET=...), 
         так и известным контроллеру внутренним идентификатором команды.
      4. В случае, если используется внутренний идентификатор команды, то перед ним должен идти символ ?
      5. Если используется внутренний идентификатор команды, то она может содержать дополнительные параметры, 
         следующие после символа ? (например, номер канала полива для включения)
      6. По завершению списка команд к выполнению сервер должен отослать строку "[CMDEND]\r\n"
      
  Примеры команд:
  
    [~]1234#CTSET=WATER|ON - команда с ID в системе 1234, значение - включить полив
    [~]1235#?1 - команда с ID в системе 1235, значение - открыть все окна
    [~]1236#?7?2 - команда с ID в системе 1236, значение - включить полив на третьем канале
    
    
    Список внутренних идентификаторов команд:
    
      1 - открыть все окна
      2 - закрыть все окна
      3 - открыть определённое окно
      4 - закрыть определённое окно
      5 - включить полив на всех каналах
      6 - выключить полив на всех каналах
      7 - включить полив на определённом канале
      8 - выключить полив на определённом канале
      9 - включить досветку
      10 - выключить досветку
      11 - включить пин
      12 - выключить пин
      
   После принятия команды в обработку контроллер запрашивает скрипт, передавая ему идентификатор выполненной команды.
   Сервер должен помечать команду как выполненную, только если он получит ответ от контроллера о её успешном выполнении.
    
*/

  $END_OF_COMMANDS = "[CMDEND]\r\n";

  // тестовые команды
  $sample_commands = array(
    "[~]0000#CTSET=LIGHT|ON", // включить досветку
    "[~]1111#?1", // открыть все окна
    "[~]2222#?7?2" // включить полив на третьем канале
    
  );
  
  function isUserValid($key)
  {
    // тут проверяем, есть ли такой юзер в БД
    return true;
  }
  
  if(isset($incoming_data['k']) && isUserValid($incoming_data['k']) ) // только если передан ключ и мы нашли такого пользователя
  {
  
         // проверяем - не запросили ли статус выполнения команды?
         if(isset($incoming_data['r']))
         {
          // запросили статус выполнения команды, получаем идентификатор команды и помечаем её, как выполненную
          $command_identifier = @$incoming_data['c'];
          // тут помечаем команду как выполненную в БД для пары $_POST['k'] и $command_identifier
         }
         else // запросили список команд на выполнение
         {
        
            // выдаём команды клиенту из БД, ниже - просто выдаём список тестовых команд
            foreach($sample_commands as $k => $v)
            {
              echo $v . "\r\n";
            }
        } // else
  
  }
  
  echo $END_OF_COMMANDS;

?>
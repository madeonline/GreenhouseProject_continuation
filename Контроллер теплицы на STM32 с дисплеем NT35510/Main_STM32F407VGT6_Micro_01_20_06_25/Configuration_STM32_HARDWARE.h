#pragma once

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// USER SETTINGS
// ПОЛЬЗОВАТЕЛЬСКИЕ НАСТРОЙКИ
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------------------------------------------------------------
// директивы условной компиляции:
/*
    в общем случае для предварительной настройки прошивки достаточно закомментировать ту или иную директиву USE_*.
    конкретные настройки пинов и пр. - находятся после директив условной компиляции, и подхватываются только тогда,
    когда соответствующая директива USE_* определена.
 */
 //--------------------------------------------------------------------------------------------------------------------------------
// СПИСОК ЗАПРЕЩЁННЫХ ПИНОВ, КОТОРЫЕ НЕЛЬЗЯ БУДЕТ УКАЗАТЬ В КОНФИГУРАТОРЕ
//--------------------------------------------------------------------------------------------------------------------------------
// добавьте сюда пины, через запятую. Пины I2C, 0,1, SPI - уже помечены как небезопасные, и добавлять их сюда - не надо.
                        /* пины TFT-экрана, шина данных, 22-37         */
#define UNSAFE_PIN_LIST 4,11,12,13,14,15,18,19,20,22,23,26,26,27,28,29,30,31,37,38,39,40,41,42,43,44,46,47,48,49,50,52,53,55,56,57,58,61,62,63,71,72,73,74,75,76,77,78,79


//--------------------------------------------------------------------------------------------------------------------------------
// скорость работы I2C
//--------------------------------------------------------------------------------------------------------------------------------
#define MY_I2C_SPEED 100000UL // 400кГц, поменять на 100000UL для скорости 100кГц

//--------------------------------------------------------------------------------------------------------------------------------
// настройки SPI
//--------------------------------------------------------------------------------------------------------------------------------
// частота шины SPI, герц, для LoRa 
#define LORA_SPI_FREQUENCY        8000000ul 

// частота шины SPI, герц, для MCP23S17 
#define MCP_SPI_FREQUENCY        10000000ul 

//--------------------------------------------------------------------------------------------------------------------------------
// раскомментируйте эту настройку, если вам надо измерять температуру не в градусах Цельсия, а в Фаренгейтах
//#define MEASURE_TEMPERATURES_IN_FAHRENHEIT 
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не хотим использовать модуль реального времени (DS3231)
// без этого модуля многий функционал не работает, например, логгирование информации или работа модуля полива по расписанию.
// можно считать, что использование этого модуля - обязательно.
#define USE_DS3231_REALTIME_CLOCK
#define DS3231_WIRE_NUMBER 0 // номер I2C для часов (0 - первый I2C, 1 - второй I2C). В STM32GENERIC НЕТ Wire1 !!!
#define USE_INTERNAL_CLOCK // раскомментировать, если надо использовать внутренние часы STM32 (если закомментировано - используются часы DS3231)
#define USE_INTERNAL_TEMP_SENSOR // закомментировать, если не надо использовать встроенный датчик температуры
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужен модуль сценариев. Сценарии создаются при помощи программы SceneCreator.exe, и загружаются на SD-карту.
// Далее сценарии могут выполняться либо по клику на кнопке сценария на TFT-экране, либо при помощи внешних команд
// CTSET=SCN|EXEC|Number (запустить сценарий), CTSET=SCN|STOP|Number (остановить сценарий), где Number - номер сценария, начиная с 0.
#define USE_SCENE_MODULE
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужен модуль управления пинами
// этот модуль косвенно используют другие модули (например, модуль составных команд) для управления пинами
#define USE_PIN_MODULE 
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_INFO_DIODES // использовать или нет информационные диоды (готовность, режимы работы окон, полива, досветки)
//--------------------------------------------------------------------------------------------------------------------------------
// раскомментировать, если надо управлять микросхемами MCP* с внешних команд (CTGET и CTSET, а также через MQTT командами GET и SET)
#define USE_MCP_MODULE

// SET:
//    CTSET=MCP|SPI|MODE|mcpNumber|mcpChannel|pinMode, for example  CTSET=MCP|SPI|MODE|0|7|OUT, CTSET=MCP|SPI|MODE|1|2|IN
//    CTSET=MCP|SPI|WRITE|mcpNumber|mcpChannel|level, for example  CTSET=MCP|SPI|WRITE|2|10|ON, CTSET=MCP|SPI|WRITE|0|4|OFF
//    CTSET=MCP|I2C|MODE|mcpNumber|mcpChannel|pinMode, for example  CTSET=MCP|I2C|MODE|0|7|OUT, CTSET=MCP|I2C|MODE|1|2|IN
//    CTSET=MCP|I2C|WRITE|mcpNumber|mcpChannel|level, for example  CTSET=MCP|I2C|WRITE|2|10|ON, CTSET=MCP|I2C|WRITE|0|4|OFF

// GET:
//    CTGET=MCP|SPI|mcpNumber|mcpChannel
//    CTGET=MCP|I2C|mcpNumber|mcpChannel
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужна поддержка модуля статистики (FREERAM, UPTIME, DATETIME)
#define USE_STAT_MODULE
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужна поддержка управления по SMS (SIM800)
//#define USE_SMS_MODULE 
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужен модуль управления поливом (в принципе, тот же функционал можно реализовать через правила)
#define USE_WATERING_MODULE 
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужен модуль контроля освещенности (BH17500 и MAX44009)
#define USE_LUMINOSITY_MODULE 
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_HUMIDITY_MODULE // закомментировать, если не нужен модуль работы с датчиками влажности DHT, Si7021, SHT
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_SOIL_MOISTURE_MODULE // закомментировать, если не нужен модуль датчиков влажности почвы
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_PH_MODULE // закомментировать, если не нужен модуль снятия показаний с датчиков pH и контроля за дозированием реагентов в систему
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_CO2_MODULE // закомментировать, если не нужен модуль снятия показаний с датчиков C02
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_LOG_MODULE // закомментировать, если не нужен модуль логгирования информации. Внимание: модуль работает только с модулем реального времени (USE_DS3231_REALTIME_CLOCK должна быть определена!)
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_DELTA_MODULE // закомментировать, если не нужно собирать показания дельт с датчиков (разница показаний между двумя датчиками)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WATERFLOW_MODULE // закомментировать, если не нужны датчик(и) расхода воды, настройки - см. ниже
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_COMPOSITE_COMMANDS_MODULE // закомментировать, если не нужен модуль составных команд (позволяет выполнить скопом несколько разных действий, используется правилами)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_RESERVATION_MODULE // закомментировать, если не нужем модуль резервирования датчиков (когда при отсутствии показаний с одного датчика показания берутся со связанных с ним).
// модуль резервирования нужен для работы правил, если необходимо обеспечить работу правила даже тогда, когда один из датчиков вышел из строя
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_TIMER_MODULE // закомментировать, если не нужна поддержка модуля таймеров (4 таймера)
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_IOT_MODULE // закомментировать, если не нужна отсылка данных на IoT-хранилища (ThingSpeak). Настройки IoT смотрите ниже
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_ALARM_DISPATCHER // закомментировать, если не нужны тревоги (получение СМС при срабатывании правила)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_EXTERNAL_WATCHDOG // закомментировать, если не нужен внешний контроль зависания меги (мега на определённой ноге дёргает уровни, если уровни не меняются - внешний ватчдог передёргивает питание)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_MODULE_AS_IOT_GATE // закомментировать, если не хотим использовать ESP как один из шлюзов для отсыла данных в IoT
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_MODULE_AS_HTTP_PROVIDER // закомментировать, если не хотим посылать HTTP-запросы к сервису gardenboss.ru через ESP
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_MODULE_AS_MQTT_CLIENT // раскомментировать, если хотим использовать ESP как MQTT-клиент
//--------------------------------------------------------------------------------------------------------------------------------
//#define MQTT_REPORT_AS_JSON // раскомментировать, если надо публиковать топик-ответ на выполнение команды в объекте JSON
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_GSM_MODULE_AS_IOT_GATE // закомментировать, если не хотим использовать GSM-модем как один из шлюзов для отсыла данных в IoT
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_GSM_MODULE_AS_HTTP_PROVIDER // закомментировать, если не хотим посылать HTTP-запросы к сервису gardenboss.ru через GSM
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужно использовать никакие универсальные модули (если эта директива закомментирована - модули любых типов не используются),
// если раскомментирована - используются модули с датчиками на борту, исполнительные модули - используются в зависимости от настройки USE_UNI_EXECUTION_MODULE).
// если эта строка закомментирована - никакие из модулей использоваться не будут
#define USE_UNIVERSAL_MODULES
//--------------------------------------------------------------------------------------------------------------------------------
// раскомментировать, если нужна поддержка модуля с выносным дисплеем на шине RS-485 (прошивка UniversalRemoteDisplayModule)
// настройка работает только совместно с USE_RS485_GATE !!!
// настройка работает только совместно с настройкой USE_UNIVERSAL_MODULES !!!
//#define USE_REMOTE_DISPLAY_MODULE
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не надо использовать выносной модуль на 7 кнопок с привязками к командам (прошивка UniversalControlModule)
// настройка работает только совместно с настройкой USE_UNIVERSAL_MODULES !!!
//#define USE_RS485_EXTERNAL_CONTROL_MODULE
//--------------------------------------------------------------------------------------------------------------------------------
 // закомментировать, если не нужна поддержка универсальных исполнительных модулей
// настройка работает только совместно с настройкой USE_UNIVERSAL_MODULES !!!
#define USE_UNI_EXECUTION_MODULE
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужна проводная линия 1-Wire для регистрации универсальных модулей, а также линии 1-Wire для модулей
// настройка работает только совместно с настройкой USE_UNIVERSAL_MODULES !!!
#define USE_UNI_REGISTRATION_LINE
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_RS485_GATE // закомментировать, если не нужна поддержка опроса универсальных модулей по протоколу RS-485
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_NRF_GATE // закомментировать, если не нужно работать с универсальными модулями по радиоканалу nRF
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_LORA_GATE // закомментировать, если не нужно работать с универсальными модулями по радиоканалу LoRa (чипы SX1276/77/78/79)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_HTTP_MODULE // закомментировать, если не нужна проверка на входящие команды и отсыл данных на сервис gardenboss.ru

//--------------------------------------------------------------------------------------------------------------------------------
// расширители портов
//--------------------------------------------------------------------------------------------------------------------------------
// использовать или нет расширители портов MCP23S17, при этом модули, которые поддерживают работу через эти расширители, могут работать через них. 
// Настройки расширителя на SPI смотрите ниже.
#define USE_MCP23S17_EXTENDER // раскомментировать, если хотите использовать MCP23S17 (работу через них поддерживает модуль полива и модуль досветки)

// использовать или нет расширители портов MCP23017, при этом модули, которые поддерживают работу через эти расширители, могут работать через них. 
// Настройки расширителя на I2C смотрите ниже.
//#define USE_MCP23017_EXTENDER // раскомментировать, если хотите использовать MCP23017 (работу через них поддерживает модуль полива и модуль досветки)


//--------------------------------------------------------------------------------------------------------------------------------
// настройки информационных диодов (актуальны при раскомментированной настройке USE_INFO_DIODES)
//--------------------------------------------------------------------------------------------------------------------------------

//#define DISABLE_DIODES_CONFIGURE // если эта настройка РАСКОММЕНТИРОВАНА, то настройки диодов НЕДОСТУПНЫ через конфигуратор

// НАСТРОЙКИ диодов ПО УМОЛЧАНИЮ, ДЛЯ СЛУЧАЯ, КОГДА ДИРЕКТИВА DISABLE_DIODES_CONFIGURE - АКТИВНА

/* как работают диоды:
  linkUnbinded, // нет привязки
  linkDirect, // привязка напрямую к пинам
  linkMCP23S17, // привязка к MCP23S17
  linkMCP23017 // привязка к MCP23017
*/
#define DIODES_LINK_TYPE  linkUnbinded

#define DIODES_MCP_ADDRESS 1 // адрес MCP

#define DIODES_ON HIGH // уровень включения диодов

#define READY_DIODE_PIN 0 // пин (или номер канала MCP) диода готовности
#define BLINK_READY_DIODE 1 // мигать диодом готовности? (0 - нет, 1 - да)

#define WINDOWS_DIODE_PIN 1 // пин (или номер канала MCP) диода режима окон
#define WATERING_DIODE_PIN 2 // пин (или номер канала MCP) диода режима полива
#define LIGHT_DIODE_PIN 3 // пин (или номер канала MCP) диода режима досветки


//--------------------------------------------------------------------------------------------------------------------------------
// настройки RS-485 (актуальны при раскомментированной настройке USE_RS485_GATE)
//--------------------------------------------------------------------------------------------------------------------------------

#define DISABLE_RS485_CONFIGURE // если эта настройка РАСКОММЕНТИРОВАНА, то настройки RS-485 НЕДОСТУПНЫ через конфигуратор

// НАСТРОЙКИ RS-485 ПО УМОЛЧАНИЮ, ДЛЯ СЛУЧАЯ, КОГДА ДИРЕКТИВА DISABLE_RS485_CONFIGURE - АКТИВНА

#define RS485_SERIAL 3 // какой хардварный Serial будем использовать при работе с RS-485? 0 - не используется, 1 - Serial1 и т.д.

/* как работает пин управления приемом/передачей RS-485:
  linkUnbinded, // нет привязки
  linkDirect, // привязка напрямую к пинам
  linkMCP23S17, // привязка к MCP23S17
  linkMCP23017 // привязка к MCP23017
*/
#define RS485_LINK_TYPE  linkDirect

#define RS485_MCP_ADDRESS 0 // адрес MCP

#define RS485_DE_PIN PE1 // номер пина (или канала MCP) управления приемом/передачей

#define RS485_PUSH_FREQUENCY 1000ul // через сколько миллисекунд писать в шину RS-485 слепок состояния контроллера

#define RS485_ONE_SENSOR_UPDATE_INTERVAL 1234ul // // через сколько миллисекунд запрашивать с шины RS-485 показания одного датчика (полный цикл опроса будет равен интервалу*кол-во датчиков в системе)

#define RS485_BYTES_TIMEOUT 10 // кол-во байт, после неуспешной попытки вычитки которых принимать решение о таймауте (если данные по RS-485 не ходят - увеличьте это значение)

#define RS485_BAD_READINGS_RESET 5 // через сколько неудачных чтений с датчика сбрасывать его значения на вид "<нет данных>"

//--------------------------------------------------------------------------------------------------------------------------------
// Wi-Fi
//--------------------------------------------------------------------------------------------------------------------------------
// закомментировать, если не нужна поддержка управления через Wi-Fi (ESP8266)
// порт, на котором ESP слушает входящие команды в режиме точки доступа - 1975.
// ПРОШИВКА ДЛЯ ESP НАХОДИТСЯ В ПАПКЕ ESP_AT - РАБОТОСПОСОБНОСТЬ ПРОВЕРЕНА ТОЛЬКО В СВЯЗКЕ С ЭТОЙ ПРОШИВКОЙ!!!
// ИНСТРУКЦИИ ПО ПРОШИВКЕ НАХОДЯТСЯ В ТОЙ ЖЕ ПАПКЕ, В ФАЙЛЕ README.TXT!!!
// НАСТОЯТЕЛЬНО РЕКОМЕНДУЕТСЯ ИСПОЛЬЗОВАТЬ ПИН УПРАВЛЕНИЕ ПИТАНИЕМ ДЛЯ ПОЛНОГО ПЕРЕСБРОСА ESP!!!
#define USE_WIFI_MODULE

#define WIFI_PING_HOST        F("ya.ru") // хост для пингования на предмет обнаружения неполадок со связью
#define WIFI_PING_FREQUENCY   60000 // интервал пингования, миллисекунд
#define WIFI_BAD_PING_ATTEMPTS	5 // кол-во неуспешных попыток пинга, после которых ESP пересбрасывается по питанию


#define DISABLE_WIFI_CONFIGURE // если эта настройка РАСКОММЕНТИРОВАНА, то настройки WI-FI НЕДОСТУПНЫ через конфигуратор

// НАСТРОЙКИ WI-FI ПО УМОЛЧАНИЮ, ДЛЯ СЛУЧАЯ, КОГДА ДИРЕКТИВА DISABLE_WIFI_CONFIGURE - АКТИВНА

#define WIFI_SERIAL 2 // какой хардварный Serial будем использовать при работе с модемом? 0 - не используется, 1 - Serial1 и т.д.

/* как работает пин управления питанием WI-FI:
  linkUnbinded, // нет привязки
  linkDirect, // привязка напрямую к пинам
  linkMCP23S17, // привязка к MCP23S17
  linkMCP23017 // привязка к MCP23017
*/
#define WIFI_REBOOT_PIN_LINK_TYPE  linkDirect

// номер микросхемы MCP для пина управления питанием
#define WIFI_REBOOT_PIN_MCP_ADDRESS  0

// номер пина (или канала MCP) управления питанием
#define WIFI_REBOOT_PIN PB9

#define WIFI_POWER_ON LOW // уровень включения питания

//--------------------------------------------------------------------------------------------------------------------------------
// менеджер обратной связи для окон (универсальный модуль, который отдаёт информацию о положении окон и срабатывании концевиков)
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_FEEDBACK_MANAGER // закомментировать, если не нужно использовать модуль обратной связи по положению окон
// (прошивка UniversalExecutionModule с включенной обратной связью)
#define FEEDBACK_MANAGER_WAIT_TIME 15000 // если в течение указанного кол-ва миллисекунд после старта контроллера не придёт информация
// по положению окон - окна принудительно погонятся контроллером в закрытую позицию, чтобы обеспечить начальную точку отсчёта
#define FEEDBACK_MANAGER_UPDATE_INTERVAL 5000 // через сколько миллисекунд запрашивать информацию у модулей обратной связи
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
// настройки расширителей портов MCP23S17 (актуально при раскомментированной команде USE_MCP23S17_EXTENDER)
//--------------------------------------------------------------------------------------------------------------------------------
#define MCP23S17_CS_PIN 4 // номер пина chip select для микросхем MCP23S17
#define COUNT_OF_MCP23S17_EXTENDERS 1 // сколько расширителей портов MCP23S17 используется (0 - нисколько)
#define MCP23S17_ADDRESSES 1  // адреса расширителей MCP23S17, через запятую, кол-вом COUNT_OF_MCP23S17_EXTENDERS

//--------------------------------------------------------------------------------------------------------------------------------
// настройки расширителей портов MCP23017 (актуально при раскомментированной команде USE_MCP23017_EXTENDER)
//--------------------------------------------------------------------------------------------------------------------------------
#define COUNT_OF_MCP23017_EXTENDERS 0 // сколько расширителей портов MCP23017 используется (0 - нисколько)
// адреса расширителей MCP23017, через запятую, кол-вом COUNT_OF_MCP23017_EXTENDERS
// 0 - первый адрес 0x20, 1 - второй адрес 0x21 и т.п.
#define MCP23017_ADDRESSES 1,2,4,5

//--------------------------------------------------------------------------------------------------------------------------------
// НАСТРОЙКИ ВНЕШНЕГО ВАТЧДОГА (актуально при раскомментированной команде USE_EXTERNAL_WATCHDOG)
//--------------------------------------------------------------------------------------------------------------------------------
#define WATCHDOG_REBOOT_PIN PE2 //66 номер пина, на котором будут меняться уровни
#define WATCHDOG_NORMAL_LEVEL HIGH // уровень на ноге, который держится WATCHDOG_WORK_INTERVAL миллисекунд
#define WATCHDOG_TRIGGERED_LEVEL LOW // уровень импульса на ноге, который держится WATCHDOG_PULSE_DURATION миллисекунд
#define WATCHDOG_WORK_INTERVAL 1500 // через сколько миллисекунд на ноге будет уровень WATCHDOG_TRIGGERED_LEVEL
#define WATCHDOG_PULSE_DURATION 100 // сколько миллисекунд держать уровень WATCHDOG_TRIGGERED_LEVEL на ноге

//--------------------------------------------------------------------------------------------------------------------------------
// НАСТРОЙКИ УНИВЕРСАЛЬНЫХ МОДУЛЕЙ (актуально при раскомментированной команде USE_UNIVERSAL_MODULES)
//--------------------------------------------------------------------------------------------------------------------------------
#define UNI_MODULE_UPDATE_INTERVAL 2000 // через сколько мс обновлять показания с универсального модуля

//--------------------------------------------------------------------------------------------------------------------------------
// настройки nRF (актуально при раскомментированной команде USE_NRF_GATE)
//--------------------------------------------------------------------------------------------------------------------------------
#define NRF_CONTROLLER_STATE_CHECK_FREQUENCY 789 // через сколько миллисекунд проверять смену состояния контроллера (для отсылки в эфир при изменениях)
#define UNI_DEFAULT_RF_CHANNEL 19 // номер канала nRF по умолчанию

#define DISABLE_NRF_CONFIGURE // если эта настройка РАСКОММЕНТИРОВАНА, то настройки nRF НЕДОСТУПНЫ через конфигуратор

// НАСТРОЙКИ nRF ПО УМОЛЧАНИЮ, ДЛЯ СЛУЧАЯ, КОГДА ДИРЕКТИВА DISABLE_NRF_CONFIGURE - АКТИВНА


/* как работает пин управления питанием nRF:
  linkUnbinded, // нет привязки
  linkDirect, // привязка напрямую к пинам
  linkMCP23S17, // привязка к MCP23S17
  linkMCP23017 // привязка к MCP23017
*/
#define NRF_REBOOT_PIN_LINK_TYPE  linkUnbinded

#define NRF_REBOOT_PIN_MCP_ADDRESS 0 // номер MCP

#define NRF_REBOOT_PIN 0xFF // пин управления питанием (0xFF - не используется)

#define NRF_POWER_ON HIGH // уровень включения питания

#define NRF_CE_PIN 0xFF // пин CE (0xFF - не используется)
#define NRF_CSN_PIN 0xFF // пин CSN (0xFF - не используется)
#define NRF_AUTOACK_INVERTED 0 // инвертированный auto ack? (0 - нет, 1 - да)


//--------------------------------------------------------------------------------------------------------------------------------
// настройки LoRa (актуально при раскомментированной команде USE_LORA_GATE)
//--------------------------------------------------------------------------------------------------------------------------------
#define LORA_CONTROLLER_STATE_CHECK_FREQUENCY 789 // через сколько миллисекунд проверять смену состояния контроллера (для отсылки в эфир при изменениях)

//#define DISABLE_LORA_CONFIGURE // если эта настройка РАСКОММЕНТИРОВАНА, то настройки LoRa НЕДОСТУПНЫ через конфигуратор

// НАСТРОЙКИ LoRa ПО УМОЛЧАНИЮ, ДЛЯ СЛУЧАЯ, КОГДА ДИРЕКТИВА DISABLE_LORA_CONFIGURE - АКТИВНА


/* как работает пин управления питанием LoRa:
  linkUnbinded, // нет привязки
  linkDirect, // привязка напрямую к пинам
  linkMCP23S17, // привязка к MCP23S17
  linkMCP23017 // привязка к MCP23017
*/
#define LORA_REBOOT_PIN_LINK_TYPE  linkUnbinded

#define LORA_REBOOT_PIN_MCP_ADDRESS 0 // номер MCP

#define LORA_REBOOT_PIN 0xFF // пин управления питанием (0xFF - не используется)

#define LORA_POWER_ON HIGH // уровень включения питания

#define LORA_SS_PIN 0xFF // пин SS (0xFF - не используется)
#define LORA_RESET_PIN 0xFF // пин RESET (0xFF - не используется)
#define LORA_TX_POWER 17 // мощность передатчика (1 - 17)
#define LORA_FREQUENCY 868 // частота работы (433, 868, 915)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки EEPROM (МИНИМАЛЬНЫЙ ОБЪЁМ EEPROM - 16 Кб !!!)
//--------------------------------------------------------------------------------------------------------------------------------
/*
ПОДДЕРЖИВАЕМЫЕ ТИПЫ ПАМЯТИ:

  EEPROM_BUILTIN // встроенный EEPROM
  EEPROM_AT24C32 // I2C-память AT24C32 
  EEPROM_AT24C64 // I2C-память AT24C64 
  EEPROM_AT24C128 // I2C-память AT24C128 - МИНИМАЛЬНЫЙ НЕОБХОДИМЫЙ ОБЪЁМ !!! 
  EEPROM_AT24C256 // I2C-память AT24C256 
  EEPROM_AT24C512 // I2C-память AT24C512 
*/
#define EEPROM_USED_MEMORY EEPROM_AT24C128 // используем внешнюю память I2C AT24C128
// если используется внешнняя память AT24C* - то ниже определяется индекс микросхемы. Например, китайский модуль часов реального времени
// с DS3231 на борту имеет модуль памяти с адресом на шине I2C 0x57, т.е. индекс такого модуля - 7, т.к. базовый адрес памяти на шине - 
// 0x50. Настройкой ниже можно указать адрес микросхемы памяти на шине I2C.
#define EEPROM_MEMORY_INDEX 0

//--------------------------------------------------------------------------------------------------------------------------------
// настройки информационных диодов 
//--------------------------------------------------------------------------------------------------------------------------------
#define WORK_MODE_BLINK_INTERVAL 500 // с какой частотой мигать на пинах индикации ручного режима работы, мс
#define READY_DIODE_BLINK_INTERVAL 5000 // с какой частотой мигать диодом работы, мс

//--------------------------------------------------------------------------------------------------------------------------------
// настройки SD
//--------------------------------------------------------------------------------------------------------------------------------
//#define SDCARD_CS_PIN 52 // номер пина Chip Select для SD-модуля 


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля правил
//--------------------------------------------------------------------------------------------------------------------------------
//#define ALERT_INCLUDE_COMMA_VALUES // раскомментировать, если в правилах надо сравнивать не только целую часть показаний, но и дробную

// закомментировать, если хотите, чтобы в режиме слежения за состоянием пина модуль правил читал прямо из него. При этом пин настраивается
// на вход. Если настройка активна - в режиме слежения за пином модуль правил читает из карты состояний пинов, не трогая пин контроллера.
// ВНИМАНИЕ: ПРИ РАБОТЕ С ПИНАМИ, НАСТРАИВАЕМЫМИ ТОЛЬКО НА ВХОД  - ДАННАЯ НАСТРОЙКА ДОЛЖНА
// БЫТЬ ЗАКОММЕНТИРОВАНА, Т.К. СОСТОЯНИЕ ТАКИХ ПИНОВ НЕ ПОПАДАЕТ В КАРТУ ПИНОВ !!!
//#define ALERT_DONT_READ_PIN_DIRECT

//--------------------------------------------------------------------------------------------------------------------------------
// настройки интервалов обновлений модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define ALERT_UPDATE_INTERVAL 500 // интервал обновления состояния модуля ALERT, мс. Нужен, чтобы часто не разрешать зависимости - это ресурсоёмкая операция.
#define LOGGING_INTERVAL 300000 // интервал логгирования, мс (300000 - каждые 5 минут и т.п.)
#define LUMINOSITY_UPDATE_INTERVAL 3000 // через сколько мс обновлять показания с датчиков освещенности 
#define HUMIDITY_UPDATE_INTERVAL 5000 // через сколько мс обновлять показания с датчиков влажности
#define TEMP_UPDATE_INTERVAL 4990 // через сколько мс обновлять показания с датчиков температуры
#define DELTA_UPDATE_INTERVAL 5010 // через сколько миллисекунд обновлять показания дельт?


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля CO2 (актуально при раскомментированной команде USE_CO2_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define CO2_UPDATE_INTERVAL 5000 // интервал обновления показаний с датчиков CO2 (можно менять через конфигуратор потом)
#define MAX_CO2_SENSOR_PPM 5000 // максимальное измеряемое датчиком значение PPM (можно менять через конфигуратор потом)
#define CO2_PPM_MIN_ADC_VALUE 200 // значение АЦП для минимального показания датчика (можно менять через конфигуратор потом)
#define CO2_PPM_MAX_ADC_VALUE 1000 // значение АЦП для максимального показания датчика (можно менять через конфигуратор потом)

// периодичность смены уровня на пине сигнализации опасного уровня СО2, миллисекунд
#define CO2_ALERT_DURATION 500

// процент превышения CO2 от установленного, по превышению которого текущий уровень CO2 будет считаться опасным
// (например, если держим 100 ppm, гистерезис - 10 ppm, в этой настройке - 20, то по превышению 130 ppm включится сигнализация)
// (можно менять через конфигуратор потом)
#define CO2_ALERT_PERCENTS 30

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля контроля pH (РАБОТАЕТ ЧЕРЕЗ МИКРОСХЕМУ PCF8574T на шине I2C, или через MCP23*17) (актуально при раскомментированной команде USE_PH_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
/*
 Принцип работы модуля контроля pH:
 
   1. Все каналы заведены через микросхему MCP23*17 (или напрямую);
      
   2. К одному из каналов подключен датчик понижения уровня жидкости в ёмкости с рабочим раствором, 
      который при срабатывании выдаёт сигнал определённого уровня;
      
   3. При срабатывании датчика уровня начинается пополнение ёмкости с рабочим раствором, для этого на канал, 
      к которому подключен клапан подачи воды - подаётся определённый уровень;
      
   4. Как только ёмкость заполнена - начинается контроль pH;
   
   5. При отклонении pH от нужных значений, в зависимости от направления отклонения - 
      на каналы клапанов для повышения/понижения значения pH подаётся нужный уровень;
      
   6. После подачи корректировочного раствора в нужном объёме на канал управление насосом, 
      перемешивающим рабочий раствор, подаётся нужный уровень;
      
   7. После окончания перемешивания система продолжает контролировать pH, периодически при необходимости 
      повторяя вышеописанные действия, чтобы добиться требуемого уровня pH.
   
 */
//--------------------------------------------------------------------------------------------------------------------------------

#define PH_MV_PER_7_PH 2000 // кол-во милливольт, при  которых датчик показывает 7 pH
#define PH_FLOW_LEVEL_TRIGGERED HIGH // уровень, при котором датчик уровня воды считается сработавшим
#define PH_OUTPUTS_LEVEL_TRIGGERED LOW // уровень включения выходов

#define PH_SAMPLES_PER_MEASURE 10 // сколько делать замеров на одно измерение pH (1-255)
#define PH_SAMPLES_INTERVAL 20 // сколько миллисекунд между замерами в одном цикле измерения делать (10 - 255)
#define PH_UPDATE_INTERVAL 15678 // через сколько миллисекунд обновлять показания с датчика pH, прикреплённого к меге
#define PH_DEFAULT_CALIBRATION 0 // поправочное число по умолчанию, в сотых долях (т.е. 1 - это 0,01 сотая, 10 - это 0,1 и т.п.)
#define PH_DEFAULT_TARGET 700 // желаемое значение pH раствора на выходе, по умолчанию, целое число (700 = 7.00, 651 = 6.51 и т.п.)

// значение гистерезиса по умолчанию, в сотых долях (50 = 0.5, 100 = 1.0, 123 = 1.23 и т.п.). 
// Если pH раствора находится в рамках гистерезиса - корректировки pH не происходит.
#define PH_DEFAULT_HISTERESIS 50 // гистерезис

#define PH_DEFAULT_MIX_PUMP_TIME 60 // время работы насоса перемешивания по умолчанию, после каждой корректировки pH, секунд
#define PH_DEFAULT_REAGENT_PUMP_TIME 2 // время работы подачи реагента по умолчанию, для изменения pH на 0.1, секунд

#define PH_CONTROL_CHECK_INTERVAL 10000 // через сколько миллисекунд контролировать значение pH на предмет попадания в эталонный диапазон



//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля датчиков влажности почвы (актуально при раскомментированной команде USE_SOIL_MOISTURE_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define SOIL_MOISTURE_UPDATE_INTERVAL 10000 // через сколько мс обновлять показания с датчиков влажности почвы

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля температур/управления фрамугами
//--------------------------------------------------------------------------------------------------------------------------------
#define DEF_OPEN_INTERVAL 3000 // по умолчанию 3 секунды работы мотора на полное открытие/закрытие фрамуги
#define DEF_OPEN_TEMP 25 // температура открытия по умолчанию, градусов Цельсия
#define DEF_CLOSE_TEMP 24 // температура закрытия по умолчанию, градусов Цельсия
#define WINDOW_POSITION_HISTERESIS 100 // кол-во миллисекунд работы моторов, которое следует игнорировать, если текущая позиция окон
// находится в рамках этого гистерезиса, т.е. разница текущей позиции и запрошенной - меньше гистерезиса

// На каждом пине окна висит одно реле, пара реле (например,
// 40 и 41) образуют одну пару управления DC-мотором. 
// Как подключается мотор: контакты двигателя подключаются к общим (COM) контактам пары реле.
// Плюс питания - к NO (нормально разомкнутым контактам пары реле).
// Минус питания - к NC (нормально замкнутым контактам реле).


//--------------------------------------------------------------------------------------------------------------------------------
// настройки концевиков для окон. Для каждого окна - два концевика, на открытие и закрытие.
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WINDOWS_ENDSTOPS // закомментировать, если не нужно использовать концевики для окон


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления поливом (актуально при раскомментированной команде USE_WATERING_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------

// закомментировать, если не надо использовать защиту полива (уровни на определённых пинах, при которых полив включаться не будет).
// защиту полива можно использовать, например, для предотвращения включения насоса тогда, когда в системе нет воды,
// или тогда, когда температура воды ниже определённого уровня
 //#define USE_WATERING_GUARD

 // уровень на пине, при котором тревога полива считается сработавшей
 #define WATERING_GUARD_ALERT HIGH
 
 // определения пинов, с которых будет читаться уровень. Если уровень хотя бы на одном из пинов равен уровню WATERING_GUARD_ALERT - 
 // то полив и насосы сразу выключатся. Пины могут быть как реальными, так и виртуальными (с номерами от 80 до 127),
 // что даёт возможность управлять уровнем виртуальных пинов через правила - например, можно создать правило, которое выставит нужный уровень
 // на виртуальном пине тогда, когда температура на датчике ниже пороговой, а также создать правило, которое будет сбрасывать уровень на пине
 // на противоположный, когда температура воды для полива - приемлема.
 // пины перечисляются через запятую!
 #define WATERING_GUARD_PINS 80, 81, 82
 
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Настройки пищалки
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// раскомментировать, если надо использовать пищалку для звуков при нажатии кнопок TFT-экрана
#define USE_BUZZER 

#define DISABLE_BUZZER_CONFIGURE // если эта настройка РАСКОММЕНТИРОВАНА, то настройки пищалки НЕДОСТУПНЫ через конфигуратор

// НАСТРОЙКИ ПИЩАЛКИ ПО УМОЛЧАНИЮ, ДЛЯ СЛУЧАЯ, КОГДА ДИРЕКТИВА DISABLE_BUZZER_CONFIGURE - АКТИВНА

/* как работает пищалка:
  linkUnbinded, // нет привязки
  linkDirect, // привязка напрямую к пинам
  linkMCP23S17, // привязка к MCP23S17
  linkMCP23017 // привязка к MCP23017
*/
#define BUZZER_LINK_TYPE  linkDirect

// номер микросхемы MCP
#define BUZZER_MCP_ADDRESS 0

// уровень включения пищалки
#define BUZZER_LEVEL HIGH

// пин пищалки
#define BUZZER_PIN PD11

// длительность писка, миллисекунд
#define BUZZER_DURATION 60


//------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// настройки TFT
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Тач-скрин сидит на SPI2 !!!

#define  TOUCH_IRQ_Pin       GPIO_PIN_5   //  Определяем вывод информирующий о нажатии на тачскрин
#define  TOUCH_IRQ_GPIO_Port GPIOC        //  Определяем порт  TOUCH_IRQ_Pin
#define  TOUCH_PRESCALER     SPI_BAUDRATEPRESCALER_256 // прескалер для тача


// настройки для дисплея 4 дюйма, 480х800, драйвер дисплея NT35510
#define INCH_4_TFT_SCREEN_WIDTH 800  // ширина дисплея, в пикселях
#define INCH_4_TFT_SCREEN_HEIGHT 480 // высота дисплея, в пикселях

// настройки тачскрина 4''
#define INCH_4_TOUCH_CS  PB12    // Pin выбора микросхемы тачскрина
#define INCH_4_TOUCH_IRQ PC5   // Pin определения нажатия тачскрина

#define  INCH_4_TOUCH_SCALE_X INCH_4_TFT_SCREEN_WIDTH               // Размер  тача по горизонтали X (по умолчанию совпадает с шириной дисплея)
#define  INCH_4_TOUCH_SCALE_Y INCH_4_TFT_SCREEN_HEIGHT              // Размер тача по вертикали  Y (по умолчанию совпадает с высотой дисплея)

#define  INCH_4_TOUCH_MIN_RAW_X 260     // Реальная минимальная величина по оси X (подстроить под конкретный дисплей)
#define  INCH_4_TOUCH_MAX_RAW_X 3750    // Реальная максимальная величина по оси X(подстроить под конкретный дисплей)

#define  INCH_4_TOUCH_MIN_RAW_Y 245     // Реальная минимальная величина по оси Y (подстроить под конкретный дисплей)
#define  INCH_4_TOUCH_MAX_RAW_Y 3850    // Реальная максимальная величина по оси Y(подстроить под конкретный дисплей)

#define INCH4_TOUCH_ROTATION 4 // какой поворот делать для тача дисплея 4 дюйма (0-4)?
#define INCH4_ROTATION 3 // поворот дисплея 4 дюйма


// настройки для дисплея 7 дюймов, 480х800, драйвер дисплея SSD1963
#define INCH_7_TFT_SCREEN_WIDTH 800  // ширина дисплея, в пикселях
#define INCH_7_TFT_SCREEN_HEIGHT 480 // высота дисплея, в пикселях

// настройки тачскрина 7''
#define INCH_7_TOUCH_CS  PB12    // Pin выбора микросхемы тачскрина
#define INCH_7_TOUCH_IRQ PC5   // Pin определения нажатия тачскрина

#define  INCH_7_TOUCH_SCALE_X INCH_7_TFT_SCREEN_WIDTH               // Размер  тача по горизонтали X (по умолчанию совпадает с шириной дисплея)
#define  INCH_7_TOUCH_SCALE_Y INCH_7_TFT_SCREEN_HEIGHT              // Размер тача по вертикали  Y (по умолчанию совпадает с высотой дисплея)

#define  INCH_7_TOUCH_MIN_RAW_X 215     // Реальная минимальная величина по оси X (подстроить под конкретный дисплей)
#define  INCH_7_TOUCH_MAX_RAW_X 3900    // Реальная максимальная величина по оси X(подстроить под конкретный дисплей)

#define  INCH_7_TOUCH_MIN_RAW_Y 460     // Реальная минимальная величина по оси Y (подстроить под конкретный дисплей)
#define  INCH_7_TOUCH_MAX_RAW_Y 3800    // Реальная максимальная величина по оси Y(подстроить под конкретный дисплей)

#define INCH7_TOUCH_ROTATION 1 // какой поворот делать для тача дисплея 7 дюймов (0-4)?
#define INCH7_ROTATION 3 // поворот дисплея 7 дюймов
    

#define DISABLE_TFT_CONFIGURE // если эта настройка РАСКОММЕНТИРОВАНА, то настройки TFT НЕДОСТУПНЫ через конфигуратор

// НАСТРОЙКИ TFT ПО УМОЛЧАНИЮ, ДЛЯ СЛУЧАЯ, КОГДА ДИРЕКТИВА DISABLE_TFT_CONFIGURE - АКТИВНА


/* как работает пин управления подсветкой TFT:
  linkUnbinded, // нет привязки
  linkDirect, // привязка напрямую к пинам
  linkMCP23S17, // привязка к MCP23S17
  linkMCP23017 // привязка к MCP23017
*/
#define TFT_BACKLIGHT_LINK_TYPE  linkDirect

#define TFT_BACKLIGHT_MCP_ADDRESS 4 // номер MCP

#define TFT_BACKLIGHT_PIN PB1 // номер пина (или канала MCP) управления подсветкой TFT

#define TFT_BACKLIGHT_ON LOW // уровень включения подсветки

#define TFT_INIT_DELAY 100 // сколько миллисекунд (при необходимости) ждать перед отсылкой первых команд на дисплей

#define TFT_OFF_DELAY 360000ul // время выключения подсветки экрана при бездействии, миллисекунд

#define TFT_DISPLAY_TYPE 2 // тип дисплея (0 - не используется, 1 - 7 дюймов, 2 - 4 дюйма)  
  

//--------------------------------------------------------------------------------------------------------------------------------
// настройки TFT, общие для всех дисплеев
//--------------------------------------------------------------------------------------------------------------------------------

// разделитель целой и дробной части показаний, по умолчанию - запятая (charComma). Используйте charDot для точки.
#define TFT_SENSOR_DECIMAL_SEPARATOR charComma 


// через сколько миллисекунд перечитывать показания с датчиков
#define TFT_SENSORS_UPDATE_INTERVAL 5000 


//--------------------------------------------------------------------------------------------------------------------------------
// Настройки для модуля с выносным дисплеем (актуально при раскомментированной команде USE_REMOTE_DISPLAY_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// интервал обновления показаний датчиков на экране ожидания выносного дисплея, мс
#define REMOTE_DISPLAY_UPDATE_INTERVAL 15000

// настройки датчиков для выносного дисплея.
// записываются в фигурных скобках, через запятую. Внутри фигурных скобок через запятую указывается - тип показаний, индекс датчика, имя модуля.
// данные передаются на выносной дисплей в том порядке, в котором их прописали.
#define REMOTE_DISPLAY_SENSORS { StateTemperature,0,"STATE" }, { StateHumidity,1,"HUMIDITY" }, { StateLuminosity,0,"LIGHT" }


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля учёта воды (актуально при раскомментированной команде USE_WATERFLOW_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
// поддерживаемые типы датчиков - китайские water flow meter с датчиком Холла.

// сколько пульсаций в секунду выдаёт датчик при протекании литра за минуту - 
// калибровочное значение, если не совпадает с реальным расходом - подбирать!
#define WATERFLOW_CALIBRATION_FACTOR 45 // фактор калибровки по умолчанию, можно потом менять через конфигуратор

#define WATERFLOW_CHECK_FREQUENCY 2000 // через сколько мс обновлять показания с датчиков расхода

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления по SMS (модем  SIM800) (актуально при раскомментированной команде USE_SMS_MODULE)
//--------------------------------------------------------------------------------------------------------------------------------
#define GSM_PING_HOST F("ya.ru") // хост, который пингуем

#define WORK_STARTED_SMS_TEXT F("Контроллер начал работу.") // текст СМС, который будет посылаться при старте контроллера в работу

// настройки датчиков для СМС статистики по умолчанию (если нет SD-карты или там ничего не сохранено)
// индексы модулей:
// 1 - модуль температур
// 2 - модуль влажности
// 3 - модуль освещённости
// 4 - модуль влажности почвы

#define STATUS_SMS_DEFAULT_MODULE1 1 // модуль для первого датчика
#define STATUS_SMS_DEFAULT_SENSOR1 0 // индекс датчика в первом модуле
#define STATUS_SMS_DEFAULT_LABEL1 F("Твнутр") // подпись по умолчанию для первого датчика

#define STATUS_SMS_DEFAULT_MODULE2 1 // модуль для второго датчика
#define STATUS_SMS_DEFAULT_SENSOR2 1 // индекс датчика во втором модуле
#define STATUS_SMS_DEFAULT_LABEL2 F("Тнаруж") // подпись по умолчанию для второго датчика


#define DISABLE_GSM_CONFIGURE // если эта настройка РАСКОММЕНТИРОВАНА, то настройки GSM НЕДОСТУПНЫ через конфигуратор

// НАСТРОЙКИ GSM ПО УМОЛЧАНИЮ, ДЛЯ СЛУЧАЯ, КОГДА ДИРЕКТИВА DISABLE_GSM_CONFIGURE - АКТИВНА

#define GSM_SERIAL 6 // какой хардварный Serial будем использовать при работе с модемом? 0 - не используется, 1 - Serial1 и т.д.

/* как работает пин управления питанием GSM:
  linkUnbinded, // нет привязки
  linkDirect, // привязка напрямую к пинам
  linkMCP23S17, // привязка к MCP23S17
  linkMCP23017 // привязка к MCP23017
*/
#define GSM_REBOOT_PIN_LINK_TYPE  linkDirect

#define GSM_REBOOT_PIN_MCP_ADDRESS 0 // адрес MCP

#define GSM_REBOOT_PIN PD3 // номер пина (или канала MCP) управления питанием

#define GSM_POWER_ON HIGH // уровень включения питания

#define GSM_PULL_GPRS 1 // пинговать GPRS-соединение? (0 - нет, 1 - да)

/* как работает пин управления POWERKEY:
  linkUnbinded, // нет привязки
  linkDirect, // привязка напрямую к пинам
  linkMCP23S17, // привязка к MCP23S17
  linkMCP23017 // привязка к MCP23017
*/
#define GSM_POWERKEY_LINK_TYPE linkDirect

#define GSM_POWERKEY_MCP_ADDRESS 0 // номер MCP для управления POWERKEY

#define GSM_POWERKEY_PIN PE0 // номер пина (или канала MCP) для управления POWERKEY

#define GSM_POWERKEY_PULSE_DURATION 300ul // длительность импульса POWERKEY, миллисекунд

#define GSM_POWERKEY_ON_LEVEL LOW // уровень включения POWERKEY

//--------------------------------------------------------------------------------------------------------------------------------
// настройки тревог (актуально при раскомментированной команде USE_ALARM_DISPATCHER)
//--------------------------------------------------------------------------------------------------------------------------------
#define ALARM_SMS_TEXT F("Тревога! Сработало правило: ") // текст СМС, который отправится при срабатывании тревожного правила, к СМС будет добавлено имя правила
//#define CLEAR_ALARM_STATUS // раскомментировать, если надо очищать сработавшие тревоги через указанный ниже промежуток времени. 
//Если тревоги не очищаются - SMS посылается однократно, до перезагрузки контроллера
#define ALARM_CLEAR_INTERVAL 10 // интервал между очистками сработавших тревог, в минутах

//--------------------------------------------------------------------------------------------------------------------------------
// синхронизация времени
//--------------------------------------------------------------------------------------------------------------------------------
#define GSM_SYNC_TIME_INTERVAL 12 // время между синхронизацией часов, в часах
#define GPRS_RECONNECT_TIME 35000 // интервал между попытками реконнекта по GPRS, мс

#define NTP_SERVER F("pool.ntp.org") // адрес NTP-сервера
#define NTP_PORT 123 // порт NTP-сервера
#define NTP_TIMEZONE 180 // смещение таймзоны (в минутах) от GMT (нулевого меридиана)
#define NTP_UPDATE_INTERVAL 12 // время между синхронизацией часов, в часах
//#define YEAR_30_FIX // раскомментировать, если надо сдвигать дату на 30 лет назад (фикс неправильного расчёта времени, когда дата оказывается сдвинутой на 30 лет вперёд)

//--------------------------------------------------------------------------------------------------------------------------------
// МОДУЛЬ ДИНАМИЧЕСКОГО СБРОСА ИНФОРМАЦИИ С WI-FI-модулей с датчиками
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_DYNAMIC_SENSORS_RESET_MODULE // использовать или нет модуль для динамического сброса информации с датчиков Wi-Fi модулей.
// данный модуль в прошивке контроллера делает следующее: если данные по датчику пришли в контроллер извне - он запоминает время получения
// данных для такого датчика. И если для датчика не будет поступать данных в течение указанного ниже интервала - то данные автоматически 
// сбросятся на показания "нет данных"

#define DYNAMIC_SENSORS_RESET_INTERVAL 60000 // через сколько миллисекунд сбрасывать данные для динамически добавленных в систему датчиков

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля измерения давления
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_PRESSURE_MODULE // закомментировать, если не надо использовать модуль давления
#define DRAW_PRESSURE_ON_SCREEN // закомментировать, если не нужно отображать давление на TFT-экране
#define PRESSURE_UPDATE_INTERVAL 10000 // интервал обновления показаний давления, миллисекунд
#define PRESSURE_SEALEVEL 114 // высота над уровнем моря точки измерения, по умолчанию

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля автоматического управления фрамугами
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WINDOW_MANAGE_MODULE // закомментировать, если не надо использовать модуль автоматического управления фрамугами 
// отображения информации датчиков дождя и ветра на TFT-экране. Если эта настройка закомментирована, то вне зависимости от
// настроек USE_WIND_SENSOR и USE_RAIN_SENSOR - показания датчиков ветра и дождя отображаться на экране не будут.

#define WINDOW_DECISION_UPDATE_INTERVAL 5000 // интервал между принятиями решений по контролю фрамуг, мс

// через сколько мс обновлять данные по дождю и ветру
// ДАННЫЙ ИНТЕРВАЛ ДОЛЖЕН БЫТЬ БОЛЬШЕ, ЧЕМ ИНТЕРВАЛ ПРИНЯТИЯ РЕШЕНИЙ ПО ОКНАМ ( см. WINDOW_DECISION_UPDATE_INTERVAL)
#define WIND_RAIN_UPDATE_INTERVAL 11023 

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля солнечной установки - ЭКСПЕРИМЕНТАЛЬНО, НЕ ТРОГАТЬ ЭТИ НАСТРОЙКИ !!!
//--------------------------------------------------------------------------------------------------------------------------------
// использовать или нет связь с контроллером солнечной установки (прошивка UniversalSunControllerModule)
//#define USE_UNI_SUN_CONTROLLER_MODULE
#define UNI_SUN_CONTROLLER_UPDATE_INTERVAL 4500 // через сколько миллисекунд запрашивать по RS-485 данные с контроллера солнечной установки


//--------------------------------------------------------------------------------------------------------------------------------
// настройки датчика ветра
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIND_SENSOR // закомментировать, если не надо использовать работу с датчиком ветра
#define WIND_SENSOR_UPDATE_INTERVAL 5000 // через сколько миллисекунд пересчитывать скорость ветра
#define WIND_SENSOR_INT_LEVEL FALLING // уровень для прерывания

//--------------------------------------------------------------------------------------------------------------------------------
// настройки датчика дождя
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_RAIN_SENSOR // закомментировать, если не нужно использовать работу с датчиком дождя

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления отоплением
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_HEAT_MODULE // закомментировать, если не надо использовать модуль управления контурами отопления

#define HEAT_DECISION_UPDATE_INTERVAL 10000 // интервал между принятиями решений по контролю отопления, мс
#define HEAT_STATUS_UPDATE_INTERVAL 5000 // интервал обновления статуса контуров отопления на стартовом экране

#define HEAT_MAX_ALLOWED_TEMP 120 // максимальное значение температуры контура при редактировании
#define HEAT_MAX_WORK_TIME 180 // максимальное время работы приводов, с, для редактирования

//расчет мощности для отопления по ПИ закону регулирования

#define HEAT_kP                   6     // коэффициент пропорциональности
#define HEAT_P_MIN                0.0   // минимум П составляющей - не < 0
#define HEAT_P_MAX                100.0 // максимум П составляющей - не > 100 
#define HEAT_kI                   0.025 // коэффициент интегрирования
#define HEAT_I_MIN                0.0   // минимум И составляющей
#define HEAT_I_MAX                30.0  // максимум И составляющей
#define HEAT_K_PROP               4.0   //зона пропорциональности "уставка - HEAT_K_PROP"


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля затенения
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_SHADOW_MODULE // закомментировать, если не надо использовать модуль затенения

#define SHADOW_MAX_WORK_TIME 180 // максимальное время работы приводов, с, для редактирования
#define SHADOW_DECISION_UPDATE_INTERVAL 10000 // интервал между принятиями решений по контролю затенения, мс

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления досветкой
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_LIGHT_MANAGE_MODULE // закомментировать, если не надо использовать модуль управления досветкой

#define LIGHT_DECISION_UPDATE_INTERVAL 10000 // интервал между принятиями решений по контролю за освещённостью, мс

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля циркуляционной вентиляции
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_CYCLE_VENT_MODULE // закомментировать, если не нужно использовать модуль циркуляционной вентиляции (3 канала)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля вентиляции по температуре
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_VENT_MODULE // закомментировать, если не надо использовать модуль вентиляции по температуре (3 канала)

#define VENT_UPDATE_INTERVAL 3000 // через сколько миллисекунд опрашиваем датчик температуры


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля термостата
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_THERMOSTAT_MODULE // закомментировать, если не надо использовать модуль термостатов (3 канала)

#define THERMOSTAT_UPDATE_INTERVAL 3000 // через сколько миллисекунд опрашиваем датчик температуры


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления входными дверями
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_DOOR_MODULE // закомментировать, если не надо использовать модуль управления входными дверями

//--------------------------------------------------------------------------------------------------------------------------------
// настройки броадкаста состояния контроллера по Wi-Fi
//--------------------------------------------------------------------------------------------------------------------------------
#define ENABLE_CONTROLLER_STATE_BROADCAST // закомментировать, если не надо отсылать состояние контроллера по Wi-Fi широковещательным пакетом
#define CONTROLLER_STATE_BROADCAST_DURATION 2000ul // через сколько миллисекунд отсылать состояние контроллера широковещательным пакетом (если состояние изменилось)
